# -*- coding: utf-8 -*-
"""Sistema_de_recomendação.pynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a0HpvyQN37ggLscIY_N2NJMPaV7C93ak
"""

import sqlite3
import pandas as pd
from IPython.display import display
import matplotlib.pyplot as plt
import ipywidgets as widgets
import seaborn as sns
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score, classification_report
from sklearn.preprocessing import OneHotEncoder, label_binarize
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.exceptions import UndefinedMetricWarning
import warnings
from imblearn.over_sampling import SMOTE
from imblearn.pipeline import Pipeline as ImbPipeline
import random
from collections import defaultdict

warnings.filterwarnings("ignore", category=UndefinedMetricWarning)

# URLs dos arquivos CSV no GitHub
links_arquivos = {
    "tabela_ocupacao_trabalho_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_ocupacao_trabalho_atualizado.csv",
    "tabela_posicao_categoria_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_posicao_categoria_atualizado.csv",
    "tabela_genero_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_genero_atualizado.csv",
    "tabela_escolaridade_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_escolaridade_atualizado.csv",
    "tabela_posicao_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_posicao_atualizado.csv",
    "tabela_condicao_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_condicao_atualizado.csv",
    "tabela_idade_atualizado": "https://github.com/CamillaSemenzzatt/PROJETO-APLICADO-III/raw/main/tabela_idade_atualizado.csv",
}

tabelas = {}

# Dicionário para mapear nomes de municípios/capitais para estados
depara_municipios = {
    'Acre': 'Acre',
    'Alagoas': 'Alagoas',
    'Amapá': 'Amapá',
    'Amazonas': 'Amazonas',
    'Aracaju (SE)': 'Sergipe',
    'Bahia': 'Bahia',
    'Belo Horizonte (MG)': 'Minas Gerais',
    'Belém (PA)': 'Pará',
    'Boa Vista (RR)': 'Roraima',
    'Brasília (DF)': 'Distrito Federal',
    'Campo Grande (MS)': 'Mato Grosso do Sul',
    'Ceará': 'Ceará',
    'Cuiabá (MT)': 'Mato Grosso',
    'Curitiba (PR)': 'Paraná',
    'Distrito Federal': 'Distrito Federal',
    'Espírito Santo': 'Espírito Santo',
    'Florianópolis (SC)': 'Santa Catarina',
    'Fonte: IBGE - Pesquisa Nacional por Amostra de Domicílios Contínua trimestral': 'Fonte: IBGE - Pesquisa Nacional por Amostra de Domicílios Contínua trimestral',
    'Fortaleza (CE)': 'Ceará',
    'Goiás': 'Goiás',
    'Goiânia (GO)': 'Goiás',
    'João Pessoa (PB)': 'Paraíba',
    'Macapá (AP)': 'Amapá',
    'Maceió (AL)': 'Alagoas',
    'Manaus (AM)': 'Amazonas',
    'Maranhão': 'Maranhão',
    'Mato Grosso': 'Mato Grosso',
    'Mato Grosso do Sul': 'Mato Grosso do Sul',
    'Minas Gerais': 'Minas Gerais',
    'Natal (RN)': 'Rio Grande do Norte',
    'Palmas (TO)': 'Tocantins',
    'Paraná': 'Paraná',
    'Paraíba': 'Paraíba',
    'Pará': 'Pará',
    'Pernambuco': 'Pernambuco',
    'Piauí': 'Piauí',
    'Porto Alegre (RS)': 'Rio Grande do Sul',
    'Porto Velho (RO)': 'Rondônia',
    'Recife (PE)': 'Pernambuco',
    'Rio Branco (AC)': 'Acre',
    'Rio Grande do Norte': 'Rio Grande do Norte',
    'Rio Grande do Sul': 'Rio Grande do Sul',
    'Rio de Janeiro': 'Rio de Janeiro',
    'Rio de Janeiro (RJ)': 'Rio de Janeiro',
    'Rondônia': 'Rondônia',
    'Roraima': 'Roraima',
    'Salvador (BA)': 'Bahia',
    'Santa Catarina': 'Santa Catarina',
    'Sergipe': 'Sergipe',
    'São Luís (MA)': 'Maranhão',
    'São Paulo': 'São Paulo',
    'Vitória (ES)': 'Espírito Santo',
    'São Paulo (SP)': 'São Paulo',
    'Teresina (PI)': 'Piauí'
}

# --- Leitura dos arquivos CSV e aplicação do depara ---
for nome_tabela, link in links_arquivos.items():
    try:
        # Tenta ler como CSV primeiro
        df = pd.read_csv(link)
        tabelas[nome_tabela] = df
    except pd.errors.ParserError:
        # Se der erro, tenta ler como tabela separada por tabulações
        df = pd.read_csv(link, sep='\t')
        tabelas[nome_tabela] = df

    # Aplica o depara_municipios se a coluna 'municipio' existir
    if 'municipio' in tabelas[nome_tabela].columns:
        tabelas[nome_tabela]['municipio'] = tabelas[nome_tabela]['municipio'].replace(depara_municipios)

        # --- Criação do banco de dados SQLite e população das tabelas ---
db_name = "projeto_aplicado.db"
conn = sqlite3.connect(db_name)

for nome_tabela, tabela in tabelas.items():
    # Use o nome da tabela do dicionário para criar a tabela no banco de dados
    tabela.to_sql(nome_tabela, conn, if_exists='replace', index=False)
    print(f"Tabela '{nome_tabela}' criada e dados inseridos no banco de dados.")

conn.close()
print("Banco de dados populado com sucesso!")

# --- Verificação das tabelas e colunas no banco de dados (Opcional) ---
conn = sqlite3.connect(db_name)
cursor = conn.cursor()

cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
tabelas_no_db = cursor.fetchall()

print("\nTabelas no banco de dados:")
for tabela in tabelas_no_db:
    nome_tabela_db = tabela[0]
    print(f"- {nome_tabela_db}")

    cursor.execute(f"PRAGMA table_info({nome_tabela_db});")
    colunas = cursor.fetchall()

    print(f"  Colunas da tabela {nome_tabela_db}:")
    for coluna in colunas:
        print(f"    - {coluna[1]}") # coluna[1] contém o nome da coluna
print("\n")

conn.close()

#junção
# --- Definição das consultas SQL ---
query_3_juncoes = """
SELECT
    o.municipio,
    o.trimestre,
    o.`Ocupação no trabalho`,
    o.`quantidade de ocupação no trabalho`,
    pc.`Posição na ocupação`,
    pc.`quantidade de posição e categoria`,
    g.Sexo,
    g.`quantidade de gênero`
FROM
    tabela_ocupacao_trabalho_atualizado o
LEFT JOIN
    tabela_posicao_categoria_atualizado pc ON o.municipio = pc.municipio AND o.trimestre = pc.trimestre
LEFT JOIN
    tabela_genero_atualizado g ON o.municipio = g.municipio AND o.trimestre = g.trimestre;
"""

query_4_juncoes = """
SELECT
    e.municipio,
    e.trimestre,
    e.`Nivel de Instrução` AS nivel_instrucao,
    e.`quantidade de escolaridade` AS quantidade_escolaridade,
    p.`posição de ocupação`,
    p.`quantidade de posição de ocupação`,
    c.`Condição de ocupação`,
    c.`quantidade de condição de ocupação`,
    i.Grupo AS grupo_etario,
    i.`quantidade de idade`
FROM
    tabela_escolaridade_atualizado e
LEFT JOIN
    tabela_posicao_atualizado p ON e.municipio = p.municipio AND e.trimestre = p.trimestre
LEFT JOIN
    tabela_condicao_atualizado c ON e.municipio = c.municipio AND e.trimestre = c.trimestre
LEFT JOIN
    tabela_idade_atualizado i ON e.municipio = i.municipio AND e.trimestre = i.trimestre;
"""

# --- Função para executar a consulta ---
def executar_consulta(query, db_name):
    conn = sqlite3.connect(db_name)
    df = pd.read_sql_query(query, conn)
    conn.close()
    return df

# --- Execução das consultas e exibição dos resultados ---
print("Executando consulta com 3 junções...")
df_3_juncoes = executar_consulta(query_3_juncoes, db_name)
print("Resultado da consulta com 3 junções:")
display(df_3_juncoes)

print("\nExecutando consulta com 4 junções...")
df_4_juncoes = executar_consulta(query_4_juncoes, db_name)
print("Resultado da consulta com 4 junções:")
display(df_4_juncoes)

print("\nProcesso concluído.")

print("\n--- Treinamento de Modelo de Classificação (RandomForestClassifier) com Amostra Reduzida ---")

# 1. Definir a Tarefa, Features (X) e Target (y)
target_classificacao = 'Condição de ocupação'

features_classificacao = [
    'municipio',
    'trimestre',
    'nivel_instrucao',
    'posição de ocupação',
    'grupo_etario',
    'quantidade_escolaridade',
    'quantidade de posição de ocupação',
    'quantidade de idade',
    'quantidade de condição de ocupação'
]

colunas_necessarias_classificacao = features_classificacao + [target_classificacao]

if all(col in df_4_juncoes.columns for col in colunas_necessarias_classificacao):

    df_modelo_classificacao = df_4_juncoes[colunas_necessarias_classificacao].copy()
    df_modelo_classificacao.dropna(subset=[target_classificacao], inplace=True)

    if df_modelo_classificacao.empty:
        print("DataFrame vazio após remover valores ausentes no target. Não é possível treinar o modelo.")
    else:
        X = df_modelo_classificacao.drop(target_classificacao, axis=1)
        y = df_modelo_classificacao[target_classificacao]

        # --- ADICIONANDO AMOSTRAGEM AQUI ---
        fracao_amostra = 0.1 # Ajuste este valor conforme necessário

        print(f"\nUsando uma amostra de {fracao_amostra*100:.0f}% dos dados para testes rápidos.")

        try:
             X_amostra, _, y_amostra, _ = train_test_split(X, y, train_size=fracao_amostra, random_state=42, stratify=y)
             print("Amostragem estratificada realizada com sucesso.")
        except ValueError as e:
             print(f"Erro ao realizar amostragem estratificada na amostra inicial: {e}. Tentando amostragem aleatória simples...")
             df_amostra = df_modelo_classificacao.sample(frac=fracao_amostra, random_state=42).copy()
             X_amostra = df_amostra.drop(target_classificacao, axis=1)
             y_amostra = df_amostra[target_classificacao]

        print(f"Tamanho da amostra total: {len(X_amostra)} amostras")
        # --- FIM DA ADIÇÃO DA AMOSTRAGEM ---

        colunas_categoricas = X_amostra.select_dtypes(include=['object', 'category']).columns.tolist()
        colunas_numericas = X_amostra.select_dtypes(include=np.number).columns.tolist()

        # 2. Pré-processar Dados usando Pipelines e ColumnTransformer - Usando a amostra
        preprocessor = ColumnTransformer(
            transformers=[
                ('num', 'passthrough', colunas_numericas),
                ('cat', OneHotEncoder(handle_unknown='ignore'), colunas_categoricas)
            ],
            remainder='passthrough'
        )

        # 3. Dividir a Amostra em Treino e Teste
        try:
            X_treino, X_teste, y_treino, y_teste = train_test_split(X_amostra, y_amostra, test_size=0.20, random_state=42, stratify=y_amostra)
        except ValueError as e:
            print(f"Erro ao dividir a amostra de treino/teste com stratify: {e}")
            print("Isso pode ocorrer se alguma classe na amostra tiver apenas uma amostra.")
            print("Tentando dividir a amostra sem stratify...")
            X_treino, X_teste, y_treino, y_teste = train_test_split(X_amostra, y_amostra, test_size=0.20, random_state=42)

        print(f"Tamanho do conjunto de treino (amostra): {len(X_treino)} amostras")
        print(f"Tamanho do conjunto de teste (amostra): {len(X_teste)} amostras")

        # 4. Definir Pipeline para RandomForestClassifier com SMOTE
        pipeline_rf = ImbPipeline(steps=[
            ('preprocessor', preprocessor),
            ('smote', SMOTE(random_state=42)),
            ('classifier', RandomForestClassifier(random_state=42))
        ])

        # 5. Treinar o Modelo (Diretamente o Pipeline)
        print("\nTreinando o Pipeline (RandomForestClassifier com SMOTE) diretamente...")
        try:
            pipeline_rf.fit(X_treino, y_treino)
            print("Fit do Pipeline concluído.")

            # --- Gerar Previsões no conjunto de teste ---
            y_pred_rf = pipeline_rf.predict(X_teste)
            print("\nPrevisões geradas para o conjunto de teste.")

            # --- Avaliar o Modelo ---
            print("\nMétricas de Avaliação no Conjunto de Teste:")

            # Acurácia
            accuracy = accuracy_score(y_teste, y_pred_rf)
            print(f"  Acurácia: {accuracy:.2f}")

            # Precisão, Revocação e F1-Score
            try:
                precision = precision_score(y_teste, y_pred_rf, average='weighted')
                recall = recall_score(y_teste, y_pred_rf, average='weighted')
                f1 = f1_score(y_teste, y_pred_rf, average='weighted')

                print(f"  Precisão (Weighted): {precision:.2f}")
                print(f"  Revocação (Weighted): {recall:.2f}")
                print(f"  F1-Score (Weighted): {f1:.2f}")

                # Relatório de Classificação completo
                print("\nRelatório de Classificação:")
                print(classification_report(y_teste, y_pred_rf))

            except ValueError as e:
                 print(f"Erro ao calcular métricas de Precisão, Revocação ou F1-Score: {e}")
                 print("Isso pode ocorrer se as previsões não contiverem todas as classes presentes nos valores reais de teste.")

            # AUC-ROC
            if hasattr(pipeline_rf, 'predict_proba'):
                try:
                    y_prob_rf = pipeline_rf.predict_proba(X_teste)
                    classes_na_amostra_total = np.unique(y_amostra)
                    y_teste_bin = label_binarize(y_teste, classes=classes_na_amostra_total)
                    n_classes = y_teste_bin.shape[1]

                    if n_classes > 1:
                         auc_roc = roc_auc_score(y_teste_bin, y_prob_rf, average='weighted')
                         print(f"  AUC-ROC (Weighted OvR): {auc_roc:.2f}")
                    else:
                         print("  AUC-ROC não calculado: Apenas uma classe presente nos dados de teste.")
                except Exception as e:
                     print(f"Erro ao calcular AUC-ROC: {e}")
                     print("Verifique se y_prob_rf foi gerado corretamente e se há mais de uma classe no conjunto de teste.")
            else:
                print("\nModelo não suporta predict_proba, AUC-ROC não calculado.")

        except Exception as e:
            print(f"\nErro durante o treinamento do Pipeline: {e}")
            print("O Pipeline não completou o treinamento.")

else:
    print("Algumas colunas necessárias para o modelo de classificação não foram encontradas em df_4_juncoes.")

# --- Função para recomendar programas sociais com porcentagem e gráfico (Sistema de Recomendação) ---
def sistema_recomendacao_porcentagem(municipio, trimestre, df_3_juncoes, df_4_juncoes):
    """
    Sistema de recomendação que sugere programas sociais com base nas características
    do município e trimestre, calcula a porcentagem de potenciais beneficiários
    e exibe um gráfico.

    Retorna uma lista de programas recomendados ordenados pela porcentagem de
    potenciais beneficiários.
    """

    dados_municipio_3 = df_3_juncoes[(df_3_juncoes["municipio"] == municipio) & (df_3_juncoes["trimestre"] == trimestre)].copy()
    dados_municipio_4 = df_4_juncoes[(df_4_juncoes["municipio"] == municipio) & (df_4_juncoes["trimestre"] == trimestre)].copy()

    if dados_municipio_3.empty and dados_municipio_4.empty:
        print(f"Nenhum dado disponível para o município: {municipio} no trimestre: {trimestre}")
        return [] # Retorna lista vazia se não houver dados

    print(f"\nAnálise para o município: {municipio} no trimestre: {trimestre}")

    total_pessoas = dados_municipio_4["quantidade de idade"].sum()

    if total_pessoas == 0:
        print("Não há registros suficientes para calcular porcentagens de beneficiários para programas sociais.")
        return [] # Retorna lista vazia se total de pessoas for zero

    porcentagens = {}

    # --- Cálculo de Porcentagens por Programa ---

    # Minha Casa Minha Vida
    if "grupo_etario" in dados_municipio_4.columns:
        beneficiarios_mcmv = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "25 a 39 anos", "quantidade de idade"].sum()
        if beneficiarios_mcmv > 0:
            porcentagem_mcmv = (beneficiarios_mcmv / total_pessoas) * 100
            porcentagens["Minha Casa Minha Vida"] = porcentagem_mcmv

    # Auxílio Emergencial
    if "grupo_etario" in dados_municipio_4.columns and "Condição de ocupação" in dados_municipio_4.columns:
        condicao_idade = dados_municipio_4["grupo_etario"].isin(["18 a 24 anos", "25 a 39 anos", "40 a 59 anos"])
        condicao_ocupacao = dados_municipio_4["Condição de ocupação"].str.contains("Fora da força de trabalho", na=False)
        beneficiarios_emergencial_df = dados_municipio_4.loc[condicao_idade & condicao_ocupacao]
        beneficiarios_emergencial = beneficiarios_emergencial_df["quantidade de idade"].sum()

        if beneficiarios_emergencial > 0:
            porcentagem_emergencial = (beneficiarios_emergencial / total_pessoas) * 100
            porcentagens["Auxílio Emergencial"] = porcentagem_emergencial

    # BPC (Benefício de Prestação Continuada)
    if "grupo_etario" in dados_municipio_4.columns or "Condição de ocupação" in dados_municipio_4.columns:
        beneficiarios_idosos = 0
        if "grupo_etario" in dados_municipio_4.columns:
            beneficiarios_idosos = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "60 anos ou mais", "quantidade de idade"].sum()

        beneficiarios_deficiencia = 0
        if "Condição de ocupação" in dados_municipio_4.columns:
             if 'quantidade de condição de ocupação' in dados_municipio_4.columns:
                  beneficiarios_deficiencia = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de condição de ocupação'].sum()
             else:
                  beneficiarios_deficiencia = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de idade'].sum()

        total_beneficiarios_bpc = beneficiarios_idosos + beneficiarios_deficiencia

        if total_beneficiarios_bpc > 0:
            porcentagem_bpc = (total_beneficiarios_bpc / total_pessoas) * 100
            porcentagens["BPC"] = porcentagem_bpc

    # Programas para jovens (18 a 24 anos)
    if "grupo_etario" in dados_municipio_4.columns:
        beneficiarios_jovens = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "18 a 24 anos", "quantidade de idade"].sum()
        if beneficiarios_jovens > 0:
            porcentagem_jovens = (beneficiarios_jovens / total_pessoas) * 100
            porcentagens["Programas para jovens"] = porcentagem_jovens

    # Brasil Alfabetizado
    if "nivel_instrucao" in dados_municipio_4.columns:
        beneficiarios_alfabetizacao = dados_municipio_4.loc[dados_municipio_4["nivel_instrucao"] == "Ensino fundamental incompleto ou equivalente", "quantidade_escolaridade"].sum()
        if beneficiarios_alfabetizacao > 0:
            porcentagem_alfabetizacao = (beneficiarios_alfabetizacao / total_pessoas) * 100
            porcentagens["Brasil Alfabetizado"] = porcentagem_alfabetizacao

    # Qualifica Mais
    if "Ocupação no trabalho" in dados_municipio_3.columns:
        condicao_qualifica = dados_municipio_3["Ocupação no trabalho"].str.contains("Trabalhadores de serviços, vendedores do comércio em lojas e mercados|Trabalhadores da produção de bens e serviços industriais", na=False, regex=True)
        beneficiarios_qualifica = dados_municipio_3.loc[condicao_qualifica, "quantidade de ocupação no trabalho"].sum()

        if beneficiarios_qualifica > 0:
             porcentagem_qualifica = (beneficiarios_qualifica / total_pessoas) * 100
             porcentagens["Qualifica Mais"] = porcentagem_qualifica


    # --- Exibição das Porcentagens e Gráfico ---
    if not porcentagens:
        print("\nNenhum programa social recomendado com base nos dados disponíveis para este município e trimestre.")
        return [] # Retorna lista vazia se não houver porcentagens

    print("\nPotenciais Programas Sociais e Porcentagem de Beneficiários:")
    # Ordena os programas por porcentagem
    programas_ordenados = sorted(porcentagens.items(), key=lambda item: item[1], reverse=True)

    for programa, percentual in programas_ordenados:
         print(f"- {programa}: {percentual:.2f}% das pessoas se enquadram nos critérios.")

    # Gera o gráfico
    if porcentagens:
        programas = [item[0] for item in programas_ordenados]
        percentuais = [item[1] for item in programas_ordenados]

        plt.figure(figsize=(14, 7))
        plt.bar(programas, percentuais, color='#2E8B57')
        plt.ylabel("Porcentagem de Pessoas Potencialmente Beneficiadas (%)")
        plt.title(f"Porcentagem de Pessoas Potencialmente Beneficiadas por Programa Social\n em {municipio} no {trimestre}")
        plt.xticks(rotation=45, ha='right')
        plt.ylim(0, 100)
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

    # Retorna a lista de programas recomendados ordenados
    return [programa for programa, _ in programas_ordenados]

# --- Implementação das Métricas de Avaliação Adaptadas ---

if conjunto_teste:
    all_true_relevance = [] # Lista de listas: relevância real para cada par município-trimestre
    all_predicted_relevance_knn = [] # Lista de listas: relevância predita pelo KNN para cada par

    # Lista de todos os programas sociais possíveis para referência
    todos_programas = [
        "Minha Casa Minha Vida",
        "Auxílio Emergencial",
        "BPC",
        "Programas para jovens",
        "Brasil Alfabetizado",
        "Qualifica Mais"
    ]

    # Vamos coletar os scores de relevância real para o cálculo do NDCG separadamente
    # para evitar problemas de reordenação dentro do loop principal de métricas binárias.
    all_relevance_scores_for_ndcg = [] # Lista de listas: scores de relevância real para cada par

    for id_teste in conjunto_teste:
        municipio_teste, trimestre_teste = id_teste.split(" - ")

        # --- Recomendações do KNN ---
        # A função recomendar_por_similaridade_knn já retorna a lista de programas recomendados ordenados
        # Para as métricas, precisamos saber quais programas FORAM recomendados (até k)
        # CORREÇÃO: Nome da variável estava incorreto
        recomendacoes_knn_ordenadas = recomendar_por_similaridade_knn(
             municipio_teste,
             trimestre_teste,
             df_4_juncoes,
             knn_model,
             scaler,
             df_features,
             df_3_juncoes
        )

        # Pega apenas os top k recomendações do KNN
        top_k_recomendacoes_knn = recomendacoes_knn_ordenadas[:k_para_metricas] # Corrigido aqui

        # --- Calcular a Relevância Real para CADA programa possível ---
        true_relevance_for_pair = []
        predicted_relevance_knn_for_pair = []
        relevance_scores_for_pair_ndcg = [] # Scores para NDCG para este par

        for programa in todos_programas:
            # Relevância real do programa (0 ou 1 para métricas binárias)
            relevancia_real = calcular_relevancia_real(
                municipio_teste,
                trimestre_teste,
                programa,
                df_3_juncoes,
                df_4_juncoes,
                limiar_relevancia_porcentagem
            )
            true_relevance_for_pair.append(relevancia_real)

            # Previsão de relevância do KNN para este programa (0 ou 1 para métricas binárias)
            previsao_knn = 1 if programa in top_k_recomendacoes_knn else 0
            predicted_relevance_knn_for_pair.append(previsao_knn)

            # Score de relevância real para o NDCG (porcentagem real)
            porcentagem_elegibilidade_real = calcular_relevancia_real(
                municipio_teste,
                trimestre_teste,
                programa,
                df_3_juncoes,
                df_4_juncoes,
                0 # Usamos limiar 0 para obter a porcentagem real
            )
            relevance_scores_for_pair_ndcg.append(porcentagem_elegibilidade_real)


        all_true_relevance.append(true_relevance_for_pair)
        all_predicted_relevance_knn.append(predicted_relevance_knn_for_pair)
        all_relevance_scores_for_ndcg.append(relevance_scores_for_pair_ndcg) # Armazena scores para NDCG


    # --- Agregar os resultados de Precisão, Revocação e F1 ---
    all_true_relevance_flat = [item for sublist in all_true_relevance for item in sublist]
    all_predicted_relevance_knn_flat = [item for sublist in all_predicted_relevance_knn for item in sublist]

    try:
        precision_knn = precision_score(all_true_relevance_flat, all_predicted_relevance_knn_flat, average='binary', zero_division=0)
        recall_knn = recall_score(all_true_relevance_flat, all_predicted_relevance_knn_flat, average='binary', zero_division=0)
        f1_knn = f1_score(all_true_relevance_flat, all_predicted_relevance_knn_flat, average='binary', zero_division=0)

        print(f"\n--- Métricas de Avaliação do Modelo KNN (com k={k_para_metricas}, limiar={limiar_relevancia_porcentagem}%) ---")
        print(f"Precisão: {precision_knn:.4f}")
        print(f"Revocação: {recall_knn:.4f}")
        print(f"F1-Score: {f1_knn:.4f}")

    except ValueError as e:
         print(f"Erro ao calcular métricas globais de Precisão/Revocação/F1: {e}")
         print("Verifique se há exemplos positivos e negativos nas relevâncias reais e preditas.")


    # --- Cálculo do NDCG Médio ---
    all_ndcg_knn = []
    for i, id_teste in enumerate(conjunto_teste):
         municipio_teste, trimestre_teste = id_teste.split(" - ")

         # Precisa obter as recomendações do KNN novamente para manter a ordem
         recomendacoes_knn_ordenadas = recomendar_por_similaridade_knn( # Corrigido aqui
             municipio_teste,
             trimestre_teste,
             df_4_juncoes,
             knn_model,
             scaler,
             df_features,
             df_3_juncoes
         )
         top_k_recomendacoes_knn = recomendaciones_knn_ordenadas[:k_para_metricas] # Corrigido aqui

         # Obter scores de relevância real na ordem do KNN
         relevance_scores_knn_ordered = []
         for programa_knn in top_k_recomendacoes_knn:
              porcentagem_real = calcular_relevancia_real(
                  municipio_teste,
                  trimestre_teste,
                  programa_knn,
                  df_3_juncoes,
                  df_4_juncoes,
                  0
              )
              relevance_scores_knn_ordered.append(porcentagem_real)

         # Obter todos os scores de relevância real para o par e ordenar para IDCG
         # Já temos all_relevance_scores_for_ndcg[i] para este par
         ideal_relevance_scores = sorted(all_relevance_scores_for_ndcg[i], reverse=True)[:k_para_metricas]

         # Calcular DCG para a lista do KNN
         dcg_knn = 0
         for j, score in enumerate(relevance_scores_knn_ordered):
              dcg_knn += score / np.log2(j + 1 + 1) # Desconto logarítmico

         # Calcular IDCG
         idcg = 0
         for j, score in enumerate(ideal_relevance_scores):
              idcg += score / np.log2(j + 1 + 1)

         # Calcular NDCG para o par
         ndcg_for_pair = dcg_knn / idcg if idcg > 0 else 0
         all_ndcg_knn.append(ndcg_for_pair)

    mean_ndcg_knn = np.mean(all_ndcg_knn)
    print(f"NDCG Médio @{k_para_metricas}: {mean_ndcg_knn:.4f}")

# --- Comparação com Baseline de Popularidade ---
# ... (Restante do código da baseline de popularidade, que não foi afetado pelo erro de digitação)

# Certifique-se que o código de cálculo das métricas e da baseline já foi executado ANTES desta célula.
# Este código apenas formata e apresenta os resultados que foram calculados.

if 'precision_knn' in globals() and 'recall_knn' in globals() and 'f1_knn' in globals() and 'mean_ndcg_knn' in globals():
    print("--- 6.2.3. Métricas de Avaliação do Modelo KNN ---")
    print("Foram adotadas métricas quantitativas para mensuração da eficácia dos modelos:")
    print(f"•\tPrecisão (Precision): {precision_knn:.4f}")
    print(f"•\tRevocação (Recall): {recall_knn:.4f}")
    print(f"•\tF1-Score: {f1_knn:.4f}")
    # Como o AUC-ROC é difícil de calcular neste contexto, podemos mencionar isso.
    # Ou, se você tiver uma adaptação específica do AUC-ROC que gerou 0.95, substitua o texto.
    print(f"•\tNDCG Médio @{k_para_metricas}: {mean_ndcg_knn:.4f}")
    print("•\tAUC-ROC: Não aplicável diretamente neste contexto de recomendação baseada em similaridade sem adaptações específicas para pontuação de itens não recomendados.")


    if 'precision_pop' in globals() and 'recall_pop' in globals() and 'f1_pop' in globals() and 'mean_ndcg_pop' in globals():
        print("\n--- Métricas de Avaliação da Baseline de Popularidade ---")
        print("Comparação com uma baseline simples baseada na popularidade global dos programas:")
        print(f"•\tPrecisão (Precision): {precision_pop:.4f}")
        print(f"•\tRevocação (Recall): {recall_pop:.4f}")
        print(f"•\tF1-Score: {f1_pop:.4f}")
        print(f"•\tNDCG Médio @{k_para_metricas}: {mean_ndcg_pop:.4f}")
        print("•\tAUC-ROC: Não aplicável diretamente (assim como para o KNN).")

else:
    print("As métricas do KNN ou da baseline de popularidade não foram calculadas.")
    print("Por favor, execute a célula de cálculo das métricas primeiro.")

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# --- Configurações para o Mapa de Calor ---
# Selecione os municípios que você quer incluir no mapa de calor
municipios_para_heatmap = ['São Paulo', 'Rio de Janeiro', 'Brasília (DF)', 'Salvador (BA)'] # Exemplo, substitua pelos seus

# Selecione os trimestres que você quer incluir (pode ser todos ou um subconjunto)
# Vamos pegar os últimos alguns trimestres para demonstração
todos_trimestres_ordenados = sorted(df_4_juncoes['trimestre'].dropna().unique())
trimestres_para_heatmap = todos_trimestres_ordenados[-8:] # Exemplo: últimos 8 trimestres

# Lista de todos os programas sociais
todos_programas = [
    "Minha Casa Minha Vida",
    "Auxílio Emergencial",
    "BPC",
    "Programas para jovens",
    "Brasil Alfabetizado",
    "Qualifica Mais"
]

# --- Preparar os dados para o Mapa de Calor ---
# Vamos criar um dataframe que terá municípios/trimestres como índice e programas como colunas
heatmap_data = pd.DataFrame(index=[f"{m} - {t}" for m in municipios_para_heatmap for t in trimestres_para_heatmap],
                            columns=todos_programas)

# Preencher o dataframe com as porcentagens de elegibilidade
if 'calcular_relevancia_real' in globals(): # Reutiliza a função para calcular a porcentagem
    for municipio in municipios_para_heatmap:
        for trimestre in trimestres_para_heatmap:
            id_municipio_trimestre = f"{municipio} - {trimestre}"
            for programa in todos_programas:
                # Calcular a porcentagem de elegibilidade (usando limiar 0 para obter a porcentagem real)
                porcentagem_elegibilidade = calcular_relevancia_real(
                    municipio,
                    trimestre,
                    programa,
                    df_3_juncoes,
                    df_4_juncoes,
                    0 # Usamos limiar 0 para obter a porcentagem real
                )
                # Armazenar a porcentagem no dataframe do heatmap
                heatmap_data.loc[id_municipio_trimestre, programa] = porcentagem_elegibilidade
else:
    print("Função 'calcular_relevancia_real' não encontrada. Execute a célula onde ela foi definida.")


# Converter os dados para tipo numérico (podem ter vindo como object)
heatmap_data = heatmap_data.astype(float)

# Lidar com valores ausentes no dataframe do heatmap (pode acontecer se não houver dados para a combinação)
heatmap_data.fillna(0, inplace=True) # Preenche NaN com 0 (ou outro valor apropriado)

# --- Gerar o Mapa de Calor ---
if not heatmap_data.empty:
    plt.figure(figsize=(16, 10)) # Ajuste o tamanho conforme necessário
    sns.heatmap(heatmap_data, annot=True, fmt=".1f", cmap="viridis", linewidths=.5)
    plt.title("Porcentagem de Potenciais Beneficiários por Programa Social, Município e Trimestre")
    plt.xlabel("Programas Sociais")
    plt.ylabel("Município - Trimestre")
    plt.xticks(rotation=45, ha='right')
    plt.yticks(rotation=0)
    plt.tight_layout()
    plt.show()
else:
    print("DataFrame para o mapa de calor está vazio. Verifique os municípios e trimestres selecionados.")

# --- Funções para Baseline de Popularidade ---

def get_all_possible_programs():
    """Retorna uma lista de todos os programas sociais potenciais que a função de recomendação considera."""
    return [
        "Minha Casa Minha Vida",
        "Auxílio Emergencial",
        "BPC",
        "Programas para jovens",
        "Brasil Alfabetizado",
        "Qualifica Mais"
    ]

def calculate_program_popularity(df_3_juncoes, df_4_juncoes):
    """Calcula a porcentagem média de potenciais beneficiários para cada programa em todos os dados."""
    program_total_beneficiaries = defaultdict(float)
    program_total_population = defaultdict(float)
    program_count = defaultdict(int)

    combinacoes_unicas_3 = df_3_juncoes[['municipio', 'trimestre']].drop_duplicates()
    combinacoes_unicas_4 = df_4_juncoes[['municipio', 'trimestre']].drop_duplicates()

    todas_combinacoes = pd.concat([combinacoes_unicas_3, combinacoes_unicas_4]).drop_duplicates().values.tolist()

    for municipio, trimestre in todas_combinacoes:
        dados_municipio_3 = df_3_juncoes[(df_3_juncoes["municipio"] == municipio) & (df_3_juncoes["trimestre"] == trimestre)].copy()
        dados_municipio_4 = df_4_juncoes[(df_4_juncoes["municipio"] == municipio) & (df_4_juncoes["trimestre"] == trimestre)].copy()

        if dados_municipio_3.empty and dados_municipio_4.empty:
            continue

        total_pessoas = dados_municipio_4["quantidade de idade"].sum()

        if total_pessoas == 0:
            continue

        # Minha Casa Minha Vida
        if "grupo_etario" in dados_municipio_4.columns:
            beneficiarios_mcmv = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "25 a 39 anos", "quantidade de idade"].sum()
            if beneficiarios_mcmv > 0:
                 program_total_beneficiaries["Minha Casa Minha Vida"] += beneficiarios_mcmv
                 program_total_population["Minha Casa Minha Vida"] += total_pessoas
                 program_count["Minha Casa Minha Vida"] += 1

        # Auxílio Emergencial
        if "grupo_etario" in dados_municipio_4.columns and "Condição de ocupação" in dados_municipio_4.columns:
            condicao_idade = dados_municipio_4["grupo_etario"].isin(["18 a 24 anos", "25 a 39 anos", "40 a 59 anos"])
            condicao_ocupacao = dados_municipio_4["Condição de ocupação"].str.contains("Fora da força de trabalho", na=False)
            beneficiarios_emergencial_df = dados_municipio_4.loc[condicao_idade & condicao_ocupacao]
            beneficiarios_emergencial = beneficiarios_emergencial_df["quantidade de idade"].sum()

            if beneficiarios_emergencial > 0:
                program_total_beneficiaries["Auxílio Emergencial"] += beneficiarios_emergencial
                program_total_population["Auxílio Emergencial"] += total_pessoas
                program_count["Auxílio Emergencial"] += 1

        # BPC (Benefício de Prestação Continuada)
        if "grupo_etario" in dados_municipio_4.columns or "Condição de ocupação" in dados_municipio_4.columns:
            beneficiarios_idosos = 0
            if "grupo_etario" in dados_municipio_4.columns:
                beneficiarios_idosos = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "60 anos ou mais", "quantidade de idade"].sum()

            beneficiarios_deficiencia = 0
            if "Condição de ocupação" in dados_municipio_4.columns:
                 if 'quantidade de condição de ocupação' in dados_municipio_4.columns:
                      beneficiarios_deficiencia = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de condição de ocupação'].sum()
                 else:
                      beneficiarios_deficiencia = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de idade'].sum()

            total_beneficiarios_bpc = beneficiarios_idosos + beneficiarios_deficiencia

            if total_beneficiarios_bpc > 0:
                program_total_beneficiaries["BPC"] += total_beneficiarios_bpc
                program_total_population["BPC"] += total_pessoas
                program_count["BPC"] += 1

        # Programas para jovens (18 a 24 anos)
        if "grupo_etario" in dados_municipio_4.columns:
            beneficiarios_jovens = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "18 a 24 anos", "quantidade de idade"].sum()
            if beneficiarios_jovens > 0:
                program_total_beneficiaries["Programas para jovens"] += beneficiarios_jovens
                program_total_population["Programas para jovens"] += total_pessoas
                program_count["Programas para jovens"] += 1

        # Brasil Alfabetizado
        if "nivel_instrucao" in dados_municipio_4.columns:
            beneficiarios_alfabetizacao = dados_municipio_4.loc[dados_municipio_4["nivel_instrucao"] == "Ensino fundamental incompleto ou equivalente", "quantidade_escolaridade"].sum()
            if beneficiarios_alfabetizacao > 0:
                program_total_beneficiaries["Brasil Alfabetizado"] += beneficiarios_alfabetizacao
                program_total_population["Brasil Alfabetizado"] += total_pessoas
                program_count["Brasil Alfabetizado"] += 1

        # Qualifica Mais
        if "Ocupação no trabalho" in dados_municipio_3.columns:
            condicao_qualifica = dados_municipio_3["Ocupação no trabalho"].str.contains("Trabalhadores de serviços, vendedores do comércio em lojas e mercados|Trabalhadores da produção de bens e serviços industriais", na=False, regex=True)
            beneficiarios_qualifica = dados_municipio_3.loc[condicao_qualifica, "quantidade de ocupação no trabalho"].sum()

            if beneficiarios_qualifica > 0:
                 program_total_beneficiaries["Qualifica Mais"] += beneficiarios_qualifica
                 program_total_population["Qualifica Mais"] += total_pessoas
                 program_count["Qualifica Mais"] += 1

    popularity_scores = {}
    for program in get_all_possible_programs():
        if program_total_population[program] > 0:
            popularity_scores[program] = (program_total_beneficiaries[program] / program_total_population[program]) * 100
        else:
            popularity_scores[program] = 0

    return popularity_scores

def recommend_by_popularity(df_3_juncoes, df_4_juncoes):
    """Recomenda programas sociais com base na popularidade geral."""
    popularity_scores = calculate_program_popularity(df_3_juncoes, df_4_juncoes)

    print("\n--- Recomendação Baseada em Popularidade (Baseline) ---")
    if not popularity_scores:
        print("Não foi possível calcular a popularidade dos programas com os dados disponíveis.")
        return

    sorted_popularity = sorted(popularity_scores.items(), key=lambda item: item[1], reverse=True)

    print("\nProgramas Sociais Recomendados por Popularidade (Potenciais Beneficiários Médios):")
    for program, score in sorted_popularity:
        print(f"- {program}: {score:.2f}% (Média geral)")

# Execute o baseline de popularidade após carregar os dados
if 'df_3_juncoes' in globals() and 'df_4_juncoes' in globals():
    recommend_by_popularity(df_3_juncoes, df_4_juncoes)
else:
    print("\nDataFrames df_3_juncoes ou df_4_juncoes não encontrados. Carregue os dados primeiro para executar o baseline.")

# --- Etapa 13: Top 3 Programas Sociais por Popularidade (Baseline) ---
print("\n--- Top 3 Programas Sociais por Popularidade (Baseline) ---")

if 'df_3_juncoes' in globals() and 'df_4_juncoes' in globals():
    try:
        # Calcula a popularidade de todos os programas
        popularity_scores = calculate_program_popularity(df_3_juncoes, df_4_juncoes)

        if popularity_scores:
            # Ordena os programas por popularidade em ordem decrescente e pega o top 3
            sorted_popularity = sorted(popularity_scores.items(), key=lambda item: item[1], reverse=True)
            top_3_programas = sorted_popularity[:3]

            if top_3_programas:
                programas = [item[0] for item in top_3_programas]
                percentuais = [item[1] for item in top_3_programas]

                plt.figure(figsize=(10, 6))
                sns.barplot(x=percentuais, y=programas, palette='Greens_d')
                plt.xlabel("Porcentagem Média de Potenciais Beneficiários (%)")
                plt.ylabel("Programa Social")
                plt.title("Top 3 Programas Sociais por Popularidade Média (Baseline)")
                plt.xlim(0, 100) # Limita o eixo X a 100%
                plt.grid(axis='x', linestyle='--', alpha=0.7)
                plt.tight_layout()
                plt.show()
                print("Gráfico dos Top 3 programas sociais por popularidade gerado.")
            else:
                print("Não foi possível identificar os Top 3 programas com base na popularidade calculada.")

        else:
            print("Não foi possível calcular a popularidade dos programas para identificar o Top 3.")
    except Exception as e:
        print(f"Não foi possível gerar o gráfico do Top 3 programas. Erro: {e}")
else:
    print("\nDataFrames df_3_juncoes ou df_4_juncoes não encontrados. Não é possível gerar o gráfico do Top 3 programas.")

print("\nProcesso de geração do gráfico do Top 3 programas concluído.")

# --- Função Aprimorada para recomendar programas sociais com porcentagem e gráfico ---
def sistema_recomendacao_porcentagem_aprimorado(municipio, trimestre, df_3_juncoes, df_4_juncoes):
    """
    Sistema de recomendação aprimorado que sugere programas sociais com base nas
    características do município e trimestre, calcula a porcentagem de potenciais
    beneficiários e exibe um gráfico.

    Além disso, recomenda programas com base na tendência histórica do município.

    Retorna uma lista de programas recomendados ordenados pela porcentagem de
    potenciais beneficiários para o trimestre selecionado.
    """

    print(f"\n--- Análise para o município: {municipio} no trimestre: {trimestre} ---")

    # Filtrar os dados para o município e trimestre específicos
    dados_municipio_3 = df_3_juncoes[(df_3_juncoes.get("municipio", "").str.contains(municipio, na=False)) & (df_3_juncoes.get("trimestre", "") == trimestre)].copy()
    dados_municipio_4 = df_4_juncoes[(df_4_juncoes.get("municipio", "").str.contains(municipio, na=False)) & (df_4_juncoes.get("trimestre", "") == trimestre)].copy()

    if dados_municipio_3.empty and dados_municipio_4.empty:
        print(f"Nenhum dado disponível para o município: {municipio} no trimestre: {trimestre}")
        return []

    # Calcular o total de pessoas como base para as porcentagens para o trimestre selecionado
    total_pessoas_trimestre = dados_municipio_4.get("quantidade de idade", pd.Series(dtype=float)).sum()

    if total_pessoas_trimestre <= 0:
        print("Não há registros suficientes com 'quantidade de idade' para calcular porcentagens de beneficiários para programas sociais no trimestre selecionado.")
        # Still proceed to calculate historical tendency
        pass
    else:
        porcentagens_trimestre = {}

        # --- Cálculo de Porcentagens por Programa para o Trimestre Selecionado ---

        # Minha Casa Minha Vida: Grupo Etário "25 a 39 anos"
        if "grupo_etario" in dados_municipio_4.columns and "quantidade de idade" in dados_municipio_4.columns:
            beneficiarios_mcmv = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "25 a 39 anos", "quantidade de idade"].sum()
            if beneficiarios_mcmv > 0:
                porcentagens_trimestre["Minha Casa Minha Vida"] = (beneficiarios_mcmv / total_pessoas_trimestre) * 100

        # Auxílio Emergencial: Grupo Etário (18-59) E Condição "Fora da força de trabalho"
        if "grupo_etario" in dados_municipio_4.columns and "Condição de ocupação" in dados_municipio_4.columns and "quantidade de idade" in dados_municipio_4.columns:
            condicao_idade = dados_municipio_4["grupo_etario"].isin(["18 a 24 anos", "25 a 39 anos", "40 a 59 anos"])
            condicao_ocupacao = dados_municipio_4["Condição de ocupação"].str.contains("Fora da força de trabalho", na=False)
            beneficiarios_emergencial_df = dados_municipio_4.loc[condicao_idade & condicao_ocupacao]
            beneficiarios_emergencial = beneficiarios_emergencial_df["quantidade de idade"].sum()
            if beneficiarios_emergencial > 0:
                porcentagens_trimestre["Auxílio Emergencial"] = (beneficiarios_emergencial / total_pessoas_trimestre) * 100

        # BPC (Benefício de Prestação Continuada): Idosos (60+) OU Pessoas com deficiência
        beneficiarios_idosos_bpc = 0
        if "grupo_etario" in dados_municipio_4.columns and "quantidade de idade" in dados_municipio_4.columns:
            beneficiarios_idosos_bpc = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "60 anos ou mais", "quantidade de idade"].sum()

        beneficiarios_deficiencia_bpc = 0
        if "Condição de ocupação" in dados_municipio_4.columns and 'quantidade de condição de ocupação' in dados_municipio_4.columns:
             beneficiarios_deficiencia_bpc = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de condição de ocupação'].sum()
        elif "Condição de ocupação" in dados_municipio_4.columns and 'quantidade de idade' in dados_municipio_4.columns:
             beneficiarios_deficiencia_bpc = dados_municipio_4.loc[dados_municipio_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de idade'].sum()

        total_beneficiarios_bpc = beneficiarios_idosos_bpc + beneficiarios_deficiencia_bpc
        if total_beneficiarios_bpc > 0:
            porcentagens_trimestre["BPC"] = (total_beneficiarios_bpc / total_pessoas_trimestre) * 100

        # Programas para jovens: Grupo Etário "18 a 24 anos"
        if "grupo_etario" in dados_municipio_4.columns and "quantidade de idade" in dados_municipio_4.columns:
            beneficiarios_jovens = dados_municipio_4.loc[dados_municipio_4["grupo_etario"] == "18 a 24 anos", "quantidade de idade"].sum()
            if beneficiarios_jovens > 0:
                porcentagens_trimestre["Programas para jovens"] = (beneficiarios_jovens / total_pessoas_trimestre) * 100

        # Brasil Alfabetizado: Nível de Instrução "Ensino fundamental incompleto ou equivalente"
        if "nivel_instrucao" in dados_municipio_4.columns and "quantidade_escolaridade" in dados_municipio_4.columns:
            beneficiarios_alfabetizacao = dados_municipio_4.loc[dados_municipio_4["nivel_instrucao"] == "Ensino fundamental incompleto ou equivalente", "quantidade_escolaridade"].sum()
            if beneficiarios_alfabetizacao > 0:
                porcentagens_trimestre["Brasil Alfabetizado"] = (beneficiarios_alfabetizacao / total_pessoas_trimestre) * 100

        # Qualifica Mais: Ocupação "Trabalhadores de serviços..." OU "Trabalhadores da produção..."
        if "Ocupação no trabalho" in dados_municipio_3.columns and "quantidade de ocupação no trabalho" in dados_municipio_3.columns:
            condicao_qualifica = dados_municipio_3["Ocupação no trabalho"].str.contains("Trabalhadores de serviços, vendedores do comércio em lojas e mercados|Trabalhadores da produção de bens e serviços industriais", na=False, regex=True)
            beneficiarios_qualifica = dados_municipio_3.loc[condicao_qualifica, "quantidade de ocupação no trabalho"].sum()
            if beneficiarios_qualifica > 0:
                 porcentagens_trimestre["Qualifica Mais"] = (beneficiarios_qualifica / total_pessoas_trimestre) * 100


        # --- Exibição das Porcentagens e Gráfico para o Trimestre Selecionado ---
        if not porcentagens_trimestre:
            print("\nNenhum programa social recomendado com base nos dados disponíveis para este município e trimestre específico.")
        else:
            print("\nPotenciais Programas Sociais e Porcentagem de Beneficiários (Trimestre Selecionado):")
            # Ordena os programas por porcentagem
            programas_ordenados_trimestre = sorted(porcentagens_trimestre.items(), key=lambda item: item[1], reverse=True)

            for programa, percentual in programas_ordenados_trimestre:
                 print(f"- {programa}: {percentual:.2f}% das pessoas se enquadram nos critérios.")

            # Gera o gráfico para o trimestre selecionado
            programas_trimestre = [item[0] for item in programas_ordenados_trimestre]
            percentuais_trimestre = [item[1] for item in programas_ordenados_trimestre]

            plt.figure(figsize=(14, 7))
            sns.barplot(x=programas_trimestre, y=percentuais_trimestre, palette="viridis")
            plt.ylabel("Porcentagem de Pessoas Potencialmente Beneficiadas (%)")
            plt.title(f"Porcentagem de Pessoas Potencialmente Beneficiadas por Programa Social\n em {municipio} no {trimestre}")
            plt.xticks(rotation=45, ha='right')
            plt.ylim(0, 100)
            plt.grid(axis='y', linestyle='--', alpha=0.7)
            plt.tight_layout()
            plt.show()

    # --- Análise de Tendência Histórica do Município ---
    print(f"\n--- Análise de Tendência Histórica para o município: {municipio} ---")

    # Filtrar dados apenas para o município selecionado, em todos os trimestres
    dados_municipio_historico_3 = df_3_juncoes[df_3_juncoes.get("municipio", "").str.contains(municipio, na=False)].copy()
    dados_municipio_historico_4 = df_4_juncoes[df_4_juncoes.get("municipio", "").str.contains(municipio, na=False)].copy()

    if dados_municipio_historico_3.empty and dados_municipio_historico_4.empty:
         print(f"Nenhum dado histórico disponível para o município: {municipio}")
         return [programa for programa, _ in programas_ordenados_trimestre] if porcentagens_trimestre else []

    # Calculate total people historically for this municipality
    total_pessoas_historico = dados_municipio_historico_4.get("quantidade de idade", pd.Series(dtype=float)).sum()

    if total_pessoas_historico <= 0:
         print("Não há registros históricos suficientes com 'quantidade de idade' para calcular a tendência de programas sociais.")
         return [programa for programa, _ in programas_ordenados_trimestre] if porcentagens_trimestre else []

    porcentagens_historico = defaultdict(list)

    # Function to calculate percentage for a program across all relevant rows in a dataframe
    def calculate_program_percentage_historico(df, criteria_col, criteria_values, quantity_col, total_quantity):
        if criteria_col in df.columns and quantity_col in df.columns:
            # Ensure criteria_values is a list for consistent filtering
            if not isinstance(criteria_values, list):
                criteria_values = [criteria_values]

            # Use .isin() for multiple criteria values
            if len(criteria_values) > 1:
                 beneficiaries = df.loc[df[criteria_col].isin(criteria_values), quantity_col].sum()
            else: # Use direct comparison for single value
                 beneficiaries = df.loc[df[criteria_col] == criteria_values[0], quantity_col].sum()

            if total_quantity > 0:
                return (beneficiaries / total_quantity) * 100
        return 0 # Return 0 if columns are missing or no beneficiaries

    # Calculate historical percentages for each program
    porcentagens_historico["Minha Casa Minha Vida"].append(calculate_program_percentage_historico(dados_municipio_historico_4, "grupo_etario", "25 a 39 anos", "quantidade de idade", total_pessoas_historico))

    # Auxílio Emergencial (special handling for combined criteria)
    if "grupo_etario" in dados_municipio_historico_4.columns and "Condição de ocupação" in dados_municipio_historico_4.columns and "quantidade de idade" in dados_municipio_historico_4.columns:
         condicao_idade_historico = dados_municipio_historico_4["grupo_etario"].isin(["18 a 24 anos", "25 a 39 anos", "40 a 59 anos"])
         condicao_ocupacao_historico = dados_municipio_historico_4["Condição de ocupação"].str.contains("Fora da força de trabalho", na=False)
         beneficiarios_emergencial_historico_df = dados_municipio_historico_4.loc[condicao_idade_historico & condicao_ocupacao_historico]
         beneficiarios_emergencial_historico = beneficiarios_emergencial_historico_df["quantidade de idade"].sum()
         if total_pessoas_historico > 0:
             porcentagens_historico["Auxílio Emergencial"].append((beneficiarios_emergencial_historico / total_pessoas_historico) * 100)
         else:
             porcentagens_historico["Auxílio Emergencial"].append(0)
    else:
         porcentagens_historico["Auxílio Emergencial"].append(0) # Add 0 if columns are missing

    # BPC (special handling for OR criteria)
    beneficiarios_idosos_bpc_historico = calculate_program_percentage_historico(dados_municipio_historico_4, "grupo_etario", "60 anos ou mais", "quantidade de idade", total_pessoas_historico)

    beneficiarios_deficiencia_bpc_historico = 0
    if "Condição de ocupação" in dados_municipio_historico_4.columns and 'quantidade de condição de ocupação' in dados_municipio_historico_4.columns:
         beneficiarios_deficiencia_bpc_historico = calculate_program_percentage_historico(dados_municipio_historico_4, "Condição de ocupação", "Pessoas com deficiência", 'quantidade de condição de ocupação', total_pessoas_historico)
    elif "Condição de ocupação" in dados_municipio_historico_4.columns and 'quantidade de idade' in dados_municipio_historico_4.columns:
         beneficiarios_deficiencia_bpc_historico = calculate_program_percentage_historico(dados_municipio_historico_4, "Condição de ocupação", "Pessoas com deficiência", 'quantidade de idade', total_pessoas_historico)

    total_beneficiarios_bpc_historico = (beneficiarios_idosos_bpc_historico * total_pessoas_historico/100) + (beneficiarios_deficiencia_bpc_historico * total_pessoas_historico/100)

    if total_pessoas_historico > 0:
         porcentagens_historico["BPC"].append((total_beneficiarios_bpc_historico / total_pessoas_historico) * 100)
    else:
         porcentagens_historico["BPC"].append(0)


    porcentagens_historico["Programas para jovens"].append(calculate_program_percentage_historico(dados_municipio_historico_4, "grupo_etario", "18 a 24 anos", "quantidade de idade", total_pessoas_historico))
    porcentagens_historico["Brasil Alfabetizado"].append(calculate_program_percentage_historico(dados_municipio_historico_4, "nivel_instrucao", "Ensino fundamental incompleto ou equivalente", "quantidade_escolaridade", total_pessoas_historico))
    porcentagens_historico["Qualifica Mais"].append(calculate_program_percentage_historico(dados_municipio_historico_3, "Ocupação no trabalho", ["Trabalhadores de serviços, vendedores do comércio em lojas e mercados", "Trabalhadores da produção de bens e serviços industriais"], "quantidade de ocupação no trabalho", total_pessoas_historico))

    # Calculate the average percentage for each program
    medias_historicas = {programa: np.mean(percentuais) for programa, percentuais in porcentagens_historico.items() if percentuais}

    if not medias_historicas:
        print("\nNenhuma tendência histórica calculada para programas sociais neste município.")
    else:
        print("\nTendência Histórica de Potenciais Beneficiários por Programa Social:")
        # Ordena os programas por média histórica
        programas_historicos_ordenados = sorted(medias_historicas.items(), key=lambda item: item[1], reverse=True)

        for programa, media_percentual in programas_historicos_ordenados:
             print(f"- {programa}: Média Histórica de {media_percentual:.2f}% das pessoas se enquadram nos critérios.")

        # Optional: Plot historical trend
        if medias_historicas:
            programas_hist = [item[0] for item in programas_historicos_ordenados]
            percentuais_hist = [item[1] for item in programas_historicos_ordenados]

            plt.figure(figsize=(14, 7))
            sns.barplot(x=programas_hist, y=percentuais_hist, palette="viridis")
            plt.ylabel("Média Histórica de Pessoas Potencialmente Beneficiadas (%)")
            plt.title(f"Tendência Histórica de Potenciais Beneficiários por Programa Social\n em {municipio}")
            plt.xticks(rotation=45, ha='right')
            plt.ylim(0, 100)
            plt.grid(axis='y', linestyle='--', alpha=0.7)
            plt.tight_layout()
            plt.show()

    # Return the list of recommended programs for the selected quarter
    return [programa for programa, _ in programas_ordenados_trimestre] if porcentagens_trimestre else []

# --- Modificação da função de escolha de município e trimestre para usar a função aprimorada ---
def escolher_municipio_e_trimestre_aprimorado():

    if 'df_3_juncoes' not in globals() or 'df_4_juncoes' not in globals():
        print("DataFrames df_3_juncoes ou df_4_juncoes não encontrados. Execute a célula de carregamento de dados primeiro.")
        return

    # Usar as opções de municípios e trimestres do df_4_juncoes (geralmente mais completo para esses campos)
    municipios_disponiveis = sorted(df_4_juncoes["municipio"].dropna().unique())
    trimestres_disponiveis = sorted(df_4_juncoes["trimestre"].dropna().unique())

    # Adiciona um valor vazio no início das opções
    municipios_disponiveis = [''] + municipios_disponiveis
    trimestres_disponiveis = [''] + trimestres_disponiveis

    municipio_widget = widgets.Dropdown(
        options=municipios_disponiveis,
        value='',
        description='Município:',
        disabled=False,
    )

    trimestre_widget = widgets.Dropdown(
        options=trimestres_disponiveis,
        value='',
        description='Trimestre:',
        disabled=False,
    )

    output_widget = widgets.Output()

    def on_change(change):
        with output_widget:
            output_widget.clear_output()  # Limpa a saída anterior
            municipio_escolhido = municipio_widget.value
            trimestre_escolhido = trimestre_widget.value

            if municipio_escolhido and trimestre_escolhido:
                # Chama a função aprimorada de recomendação
                sistema_recomendacao_porcentagem_aprimorado(municipio_escolhido, trimestre_escolhido, df_3_juncoes, df_4_juncoes)
            elif municipio_escolhido or trimestre_escolhido:
                print("Por favor, selecione tanto um município quanto um trimestre.")
            else:
                print("Selecione um município e um trimestre para ver as recomendações.")

    municipio_widget.observe(on_change, names='value')
    trimestre_widget.observe(on_change, names='value')

    display(widgets.VBox([municipio_widget, trimestre_widget, output_widget]))

# Chame a função aprimorada para exibir os widgets e iniciar o sistema de recomendação
escolher_municipio_e_trimestre_aprimorado()

from sklearn.neighbors import NearestNeighbors
from sklearn.preprocessing import StandardScaler
import pandas as pd
import numpy as np

# modelo KNN
# Assumindo que df_4_juncoes é o dataframe com dados de município/trimestre
# Selecionar features numéricas para a similaridade
features_sim = [
    'quantidade_escolaridade',
    'quantidade de posição de ocupação',
    'quantidade de idade',
    'quantidade de condição de ocupação' # Pode precisar de tratamento se for string
]

# Adicionar features categóricas após one-hot encoding
colunas_categoricas_sim = ['nivel_instrucao', 'posição de ocupação', 'grupo_etario', 'Condição de ocupação']

# Combinar dados relevantes para a análise de similaridade
# Crie uma cópia para evitar SettingWithCopyWarning
df_sim = df_4_juncoes[['municipio', 'trimestre'] + features_sim + colunas_categoricas_sim].copy()

# Lidar com valores ausentes, se houver
df_sim.dropna(subset=features_sim + colunas_categoricas_sim, inplace=True)

if df_sim.empty:
    print("DataFrame para similaridade vazio após remover valores ausentes. Não é possível prosseguir.")
else:
    # Criar uma identificação única para cada linha (município-trimestre)
    df_sim['municipio_trimestre'] = df_sim['municipio'] + ' - ' + df_sim['trimestre']
    df_sim.set_index('municipio_trimestre', inplace=True)

    # Selecionar as features para o KNN
    features_para_knn = features_sim + colunas_categoricas_sim
    df_features = df_sim[features_para_knn].copy()

    # Aplicar One-Hot Encoding em colunas categóricas
    # Removido o argumento dummy_with_na=False
    df_features = pd.get_dummies(df_features, columns=colunas_categoricas_sim)

    # Escalar as features
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(df_features)

    # Treinar o modelo KNN
    # n_neighbors é o número de vizinhos a considerar
    knn_model = NearestNeighbors(n_neighbors=5, metric='cosine') # Usando similaridade de cosseno
    knn_model.fit(X_scaled)

    # Função para encontrar vizinhos e sugerir programas com base neles
    def recomendar_por_similaridade_knn(municipio, trimestre, df_sim_original, knn_model, scaler, df_features_encoded, df_3_juncoes_original):
        """
        Recomenda programas sociais com base em municípios/trimestres similares usando KNN.
        """
        id_busca = f"{municipio} - {trimestre}"

        if id_busca not in df_features_encoded.index:
            print(f"Município/Trimestre '{id_busca}' não encontrado nos dados de similaridade.")
            return []

        # Obter a linha correspondente e escalá-la
        linha_busca = df_features_encoded.loc[[id_busca]]
        linha_busca_scaled = scaler.transform(linha_busca)

        # Encontrar os vizinhos mais próximos
        distances, indices = knn_model.kneighbors(linha_busca_scaled)

        print(f"\nVizinhos mais próximos de '{id_busca}':")
        vizinhos = []
        for i in range(1, len(distances[0])): # Ignorar o primeiro (que é a própria busca)
            vizinho_id = df_features_encoded.index[indices[0][i]]
            distancia = distances[0][i]
            vizinhos.append(vizinho_id)
            print(f"- {vizinho_id} (Distância: {distancia:.4f})")

        # Sugerir programas com base nos vizinhos
        # Vamos considerar os programas que têm alta porcentagem de elegibilidade nos vizinhos
        programas_sugeridos = defaultdict(float)

        for vizinho_id in vizinhos:
            vizinho_municipio, vizinho_trimestre = vizinho_id.split(" - ")

            # Encontrar os dados originais para o vizinho
            dados_vizinho_3 = df_3_juncoes_original[(df_3_juncoes_original.get("municipio", "").str.contains(vizinho_municipio, na=False)) & (df_3_juncoes_original.get("trimestre", "") == vizinho_trimestre)].copy()
            dados_vizinho_4 = df_sim_original[(df_sim_original["municipio"] == vizinho_municipio) & (df_sim_original["trimestre"] == vizinho_trimestre)].copy() # Usar df_sim_original para total de pessoas

            if dados_vizinho_4.empty:
                continue

            total_pessoas_vizinho = dados_vizinho_4.get("quantidade de idade", pd.Series(dtype=float)).sum()

            if total_pessoas_vizinho <= 0:
                continue

            # Calcular porcentagens de elegibilidade para o vizinho (simplificado)
            # Minha Casa Minha Vida
            beneficiarios_mcmv = dados_vizinho_4.loc[dados_vizinho_4["grupo_etario"] == "25 a 39 anos", "quantidade de idade"].sum()
            if beneficiarios_mcmv > 0:
                 programas_sugeridos["Minha Casa Minha Vida"] += (beneficiarios_mcmv / total_pessoas_vizinho) * 100

            # Auxílio Emergencial (simplificado)
            condicao_idade = dados_vizinho_4["grupo_etario"].isin(["18 a 24 anos", "25 a 39 anos", "40 a 59 anos"])
            condicao_ocupacao = dados_vizinho_4["Condição de ocupação"].str.contains("Fora da força de trabalho", na=False)
            beneficiarios_emergencial_df = dados_vizinho_4.loc[condicao_idade & condicao_ocupacao]
            beneficiarios_emergencial = beneficiarios_emergencial_df["quantidade de idade"].sum()
            if beneficiarios_emergencial > 0:
                 programas_sugeridos["Auxílio Emergencial"] += (beneficiarios_emergencial / total_pessoas_vizinho) * 100

            # BPC (simplificado)
            beneficiarios_idosos_bpc = dados_vizinho_4.loc[dados_vizinho_4["grupo_etario"] == "60 anos ou mais", "quantidade de idade"].sum()
            beneficiarios_deficiencia_bpc = 0
            if 'quantidade de condição de ocupação' in dados_vizinho_4.columns:
                 beneficiarios_deficiencia_bpc = dados_vizinho_4.loc[dados_vizinho_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de condição de ocupação'].sum()
            elif 'quantidade de idade' in dados_vizinho_4.columns:
                 beneficiarios_deficiencia_bpc = dados_vizinho_4.loc[dados_vizinho_4["Condição de ocupação"].str.contains("Pessoas com deficiência", na=False), 'quantidade de idade'].sum()

            total_beneficiarios_bpc = beneficiarios_idosos_bpc + beneficiarios_deficiencia_bpc
            if total_beneficiarios_bpc > 0:
                 programas_sugeridos["BPC"] += (total_beneficiarios_bpc / total_pessoas_vizinho) * 100


            # Programas para jovens (simplificado)
            beneficiarios_jovens = dados_vizinho_4.loc[dados_vizinho_4["grupo_etario"] == "18 a 24 anos", "quantidade de idade"].sum()
            if beneficiarios_jovens > 0:
                 programas_sugeridos["Programas para jovens"] += (beneficiarios_jovens / total_pessoas_vizinho) * 100

            # Brasil Alfabetizado (simplificado)
            if "nivel_instrucao" in dados_vizinho_4.columns and "quantidade_escolaridade" in dados_vizinho_4.columns:
                beneficiarios_alfabetizacao = dados_vizinho_4.loc[dados_vizinho_4["nivel_instrucao"] == "Ensino fundamental incompleto ou equivalente", "quantidade_escolaridade"].sum()
                if beneficiarios_alfabetizacao > 0:
                    programas_sugeridos["Brasil Alfabetizado"] += (beneficiarios_alfabetizacao / total_pessoas_vizinho) * 100

            # Qualifica Mais (simplificado)
            if "Ocupação no trabalho" in dados_vizinho_3.columns and "quantidade de ocupação no trabalho" in dados_vizinho_3.columns:
                condicao_qualifica = dados_vizinho_3["Ocupação no trabalho"].str.contains("Trabalhadores de serviços, vendedores do comércio em lojas e mercados|Trabalhadores da produção de bens e serviços industriais", na=False, regex=True)
                beneficiarios_qualifica = dados_vizinho_3.loc[condicao_qualifica, "quantidade de ocupação no trabalho"].sum()
                if beneficiarios_qualifica > 0:
                     programas_sugeridos["Qualifica Mais"] += (beneficiarios_qualifica / total_pessoas_vizinho) * 100


        # Calcular a média das porcentagens para cada programa entre os vizinhos
        programas_sugeridos_media = {prog: total / len(vizinhos) for prog, total in programas_sugeridos.items()}

        if not programas_sugeridos_media:
            print("\nNenhuma sugestão de programa baseada nos vizinhos.")
            return []

        print("\nSugestões de Programas Sociais (baseado nos vizinhos similares):")
        programas_ordenados_sugestao = sorted(programas_sugeridos_media.items(), key=lambda item: item[1], reverse=True)

        for programa, percentual in programas_ordenados_sugestao:
             print(f"- {programa}: Média de {percentual:.2f}% de elegibilidade nos vizinhos.")

        return [programa for programa, _ in programas_ordenados_sugestao]

# Exemplo de análise para um caso específico
municipio_teste = 'São Paulo'  # Escolha um município dos disponíveis
trimestre_teste = '1º trimestre 2023' # Escolha um trimestre dos disponíveis

print(f"\n--- Análise Detalhada para {municipio_teste} no {trimestre_teste} ---")

# Obter as recomendações do KNN
programas_recomendados_knn = recomendar_por_similaridade_knn(
    municipio_teste,
    trimestre_teste,
    df_4_juncoes,
    knn_model,
    scaler,
    df_features,
    df_3_juncoes
)

# Opcional: Comparar com a recomendação baseada em regras original para o mesmo ponto
# Chame a função de recomendação aprimorada original para comparação
print(f"\n--- Recomendação Baseada em Regras para {municipio_teste} no {trimestre_teste} ---")
sistema_recomendacao_porcentagem_aprimorado(municipio_teste, trimestre_teste, df_3_juncoes, df_4_juncoes)